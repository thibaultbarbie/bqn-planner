âŸ¨ ColSegmentsCircles, FK, IsValid âŸ© â‡ 

# Compute if a segment is in collision with a circle.
# First we compute if the segment endpoints are in the circle (function F)
# If F is false we compute the distance from the circle to the segment
# This function can handle multiple segments and multiple circles
# ğ•©â‰¢2â€¿nâ€¿2    ğ•¨â‰¢âŸ¨2â€¿k, kâŸ©
ColSegmentsCirclesâ† {
 câ€¿r â† ğ•¨ â‹„ r_sq â† Ã—Ëœr 
 F â† {âˆ¨Â´âˆ˜â¥ŠË˜ (r_sqâŠ¸â‰¥)â‰1 +ËÃ—Ëœ ğ•© -âŒœË˜ c}
 G â† { cacb â† ğ•© -âŒœË˜ c â‹„ ca â† âŠâ‰2 cacb â‹„ ab â† -Ëâ‰1 ğ•© 
          n â† (-âŒ¾âŠ)âˆ˜âŒ½ ab
       d_sq â† (Ã—Ëœ +Ë n Ã— ca) Ã· +ËÃ—Ëœ ab
       âˆ¨ËË˜(0 â‰¥ +Ë ca Ã— 1âŠâ‰2 cacb) âˆ§ r_sqâŠ¸â‰¥â‰1 d_sq}
 m â† Â¬F ğ•© â‹„ col â† (G m /â‰2 ğ•©)âŒ¾(mâŠ¸/) (1âŠ‘â‰¢ğ•©) â¥Š 1
}

# Output should be 2â€¿nâ€¿2 (x/y â€¿ number of q Ã— =l â€¿ A/B)
FK â† {
 lâ€¿q â†ğ•© â‹„ a â† +`Ë˜ q
 x â† âˆ¾Ë (2â†•(0Ë™âˆ¾+`))Ë˜ l Ã—Ë˜ â€¢math.Cos a
 y â† âˆ¾Ë (2â†•(0Ë™âˆ¾+`))Ë˜ l Ã—Ë˜ â€¢math.Sin a
 xâ‰y
}

IsValid â† {
  q â† (1â€¿3)â¥Š Ï€Ã—ğ•© â‹„ l â† 1â€¿3 â¥ŠâŸ¨0.5,0.5,0.5âŸ©
  circle_centers â† 2â€¿4 â¥Š [âŸ¨0,-0.5, 1, -1âŸ©, âŸ¨1,0, 0.9, 1âŸ©]
  radius â† âŸ¨0.173, 0.173, 0.08, 0.08âŸ©
  
  Â¬ âˆ¨Â´(âŸ¨circle_centers, radiusâŸ©âŠ¸ColSegmentsCircles)âˆ˜FK lâ€¿q
}
