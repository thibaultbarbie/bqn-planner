âŸ¨ RRTConnect âŸ© â‡ 
âŸ¨ IsValidâŸ© â† â€¢Import "collision.bqn"

RRTConnect â† {
 ğ•© â‹„ s â† 3 â€¢rand.Range 0  â‹„  g â† 3 â€¢rand.Range 0

 # â‰¢trees = [2, 2, size_of_each_tree]
 # trees is composed of start tree and goal tree.
 # A tree is made of two lists: the list of index of q_list to reference which node we
 # are talking about, and the list of parent of the tree.
 trees â† âŸ¨ âŸ¨âŸ¨0âŸ©, âŸ¨0âŸ©âŸ©, âŸ¨âŸ¨1âŸ©,âŸ¨0âŸ©âŸ© âŸ©
 q_list â† âŸ¨âŸ¨0.01, 0.01, 0.01âŸ©, âŸ¨0.85, 0.2, 0âŸ©âŸ©
 
 # n LinSample aâ€¿b will gives [a, a+0.001, a+0.002, (n times), b]
 LinSample â† {nâ†ğ•¨ Ã·Ëœ âŸœ(Â¯1Ã—-Â´)ğ•© â‹„ (1âŠ‘ğ•©)âˆ¾Ëœ â‰ (âŠ‘ğ•©)+ nÃ— (â‰ âŠ‘ğ•©)â€¿ğ•¨ â¥Š (âŠ¢âˆ¾âŠ¢)âŸœâ†• ğ•¨}
 # TODO the TransitionCol function should use the resolution parameter (eps)
 Col â† Â¬IsValid â‹„ TransitionCol â† {âˆ¨Â´ ColË˜ (10 LinSample ğ•©)}

 # ğ•©: The node to be compared with, ğ•¨: the specific tree (not the parent tree)
 # Output the index of the nearest node to ğ•© in the tree ğ•¨ (example: k not ğ•¨[k])
 NearestNeighbor â† {âŠ‘(âŠ¢âŠâŒŠÂ´) (ğ•¨âŠq_list) {+Â´Ã—Ëœğ•¨-ğ•©}Â¨ <ğ•© }

 # ğ•©: the node to be added, ğ•¨=(t, p): the index of the tree and the index of the parent
 AddNode â† { tâ€¿pâ†ğ•¨ â‹„ trees âˆ¾âŸœ(â‰ q_list)âŒ¾(âŠ‘(tâŠ¸âŠ‘))â†© â‹„ trees âˆ¾âŸœ(p)âŒ¾(1âŠ‘(tâŠ¸âŠ‘))â†© â‹„q_list âˆ¾âŸœ(<ğ•©)â†©}

 # ğ•©: the node q we extend toward, the index of the tree considered, the maximum distance
 Extend  â† {
   qâ€¿tâ€¿d_max â† ğ•© 
   p â† ((âŠ‘tâŠ‘trees) NearestNeighbor q) â‹„ q_near â† (pâŠ‘âŠ‘tâŠ‘ trees) âŠ‘ q_list  
    
   dist â† âˆš (+Â´Ã—Ëœ q - q_near)
   q_new â† (d_maxâ‰¤dist)  âŠ‘ qâ€¿(q_near + distÃ·Ëœd_maxÃ—(q - q_near))
   col â† TransitionCol q_nearâ€¿q_new
    
   { col ? @ ; (tâ€¿p) AddNode q_new}
   colâ€¿(Â¬ d_maxâ‰¤dist)
 }

 # ğ•©: the node q we extend toward, the index of the tree considered, the maximum distance
 Connect â† {qâ€¿tâ€¿d_max â† ğ•© â‹„ a â† Extend qâ€¿(Â¬t)â€¿d_max â‹„ ğ•ŠâŸ(Â¬âˆ¨Â´ a) ğ•© â‹„ d â† 1âŠ‘a â‹„ d}

 # ğ•©: the index of the parent, ğ•¨: the parent tree considered
 Path â† {ğ•© = 0 ? ğ•©; ğ•©âˆ¾ (ğ•¨ğ•Š (ğ•©âŠ‘ğ•¨))}
 
 LocalLoop â† {
  d_max â† 0.01 â‹„ nâ€¿solvedâ€¿path_sol â† ğ•© â‹„ t â† (2|n) 
  q_rand â† 3 â€¢rand.Range 0

  {Â¬solved ?
    solved â†© { Â¬âŠ‘(Extend q_randâ€¿tâ€¿d_max) ? Connect (âŠ‘Â¯1â†‘q_list)â€¿tâ€¿d_max ; 0 }

    {solved ? 
      a â† (1âŠ‘tâŠ‘trees) Path âŠ‘Â¯1â†‘1âŠ‘tâŠ‘trees â‹„ b â† (1âŠ‘(Â¬t)âŠ‘trees) Path âŠ‘Â¯1â†‘1âŠ‘(Â¬t)âŠ‘trees

      arâ€¿br â† {((1âŠ‘ğ•©) Path Â¯1âŠ‘1âŠ‘ğ•©) âŠ âŠ‘ğ•©}Â¨ trees

      path_sol â†© ((âŒ½ar) âˆ¾ br)âŠq_list
    
      path_sol â†© {t ? ((âŒ½bâŠâŠ‘(Â¬t)âŠ‘trees)âˆ¾(aâŠâŠ‘tâŠ‘trees) )âŠq_list ;
                      ((âŒ½aâŠâŠ‘tâŠ‘trees)âˆ¾(bâŠâŠ‘(Â¬t)âŠ‘trees) )âŠq_list}
      ; @
    }

    (1+n)â€¿solvedâ€¿path_sol;
    nâ€¿solvedâ€¿path_sol
  } 
 }

 LocalLoopâŸ10000 0â€¿0â€¿0
} 

# iterâ€¿solvedâ€¿path_sol â† RRTConnect 0
# J â† âˆ¾1â†“Â·â¥Š<âŠ¸(â‰Ë˜) #Csv util from bqn-crate
# "solution.csv" â€¢file.Lines (<",") JÂ¨ â€¢ReprÂ¨Â¨ path_sol
